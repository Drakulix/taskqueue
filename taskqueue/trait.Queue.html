<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `Queue` trait in crate `taskqueue`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, Queue">

    <title>taskqueue::Queue - Rust</title>

    <link rel="stylesheet" type="text/css" href="../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../main.css">

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'><a href='index.html'>taskqueue</a></p><script>window.sidebarCurrent = {name: 'Queue', ty: 'trait', relpath: ''};</script><script defer src="sidebar-items.js"></script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content trait">
<h1 class='fqn'><span class='in-band'>Trait <a href='index.html'>taskqueue</a>::<wbr><a class='trait' href=''>Queue</a></span><span class='out-of-band'><span id='render-detail'>
            <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                [<span class='inner'>&#x2212;</span>]
            </a>
        </span><a id='src-418' class='srclink' href='../src/taskqueue/queue/mod.rs.html#41-244' title='goto source code'>[src]</a></span></h1>
<pre class='rust trait'>pub trait Queue: <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Send.html' title='core::marker::Send'>Send</a> + <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html' title='core::marker::Sync'>Sync</a> + <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html' title='core::marker::Sized'>Sized</a> + <a class='trait' href='https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html' title='core::fmt::Debug'>Debug</a> {
    fn <a href='#tymethod.async' class='fnname'>async</a>&lt;R, F&gt;(&amp;self, task: F) -&gt; <a class='struct' href='../taskqueue/struct.Future.html' title='taskqueue::Future'>Future</a>&lt;R&gt; <span class='where'>where R: <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Send.html' title='core::marker::Send'>Send</a> + 'static, F: <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.FnOnce.html' title='core::ops::FnOnce'>FnOnce</a>() -&gt; R + <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Send.html' title='core::marker::Send'>Send</a> + 'static</span>;

    fn <a href='#method.scoped' class='fnname'>scoped</a>&lt;'queue, R, F&gt;(&amp;'queue self, task: F) -&gt; <a class='struct' href='../taskqueue/struct.FutureGuard.html' title='taskqueue::FutureGuard'>FutureGuard</a>&lt;R&gt; <span class='where'>where R: <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Send.html' title='core::marker::Send'>Send</a> + 'static, F: <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.FnOnce.html' title='core::ops::FnOnce'>FnOnce</a>() -&gt; R + <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Send.html' title='core::marker::Send'>Send</a> + 'queue</span> { ... }
    fn <a href='#method.sync' class='fnname'>sync</a>&lt;'queue, R, F&gt;(&amp;'queue self, task: F) -&gt; R <span class='where'>where R: <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Send.html' title='core::marker::Send'>Send</a> + 'static, F: <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.FnOnce.html' title='core::ops::FnOnce'>FnOnce</a>() -&gt; R + <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Send.html' title='core::marker::Send'>Send</a> + 'queue</span> { ... }
    fn <a href='#method.foreach' class='fnname'>foreach</a>&lt;'queue, B, R, I, F&gt;(&amp;'queue self, iter: I, task: F) -&gt; <a class='struct' href='../taskqueue/struct.Group.html' title='taskqueue::Group'>Group</a>&lt;R&gt; <span class='where'>where B: <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Send.html' title='core::marker::Send'>Send</a>, R: <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Send.html' title='core::marker::Send'>Send</a> + 'queue, I: <a class='trait' href='https://doc.rust-lang.org/nightly/core/iter/trait.Iterator.html' title='core::iter::Iterator'>Iterator</a>&lt;Item=B&gt; + <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Send.html' title='core::marker::Send'>Send</a>, F: <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.Fn.html' title='core::ops::Fn'>Fn</a>(B) -&gt; R + <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Send.html' title='core::marker::Send'>Send</a> + <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html' title='core::marker::Sync'>Sync</a> + 'queue</span> { ... }
    fn <a href='#method.loop_while' class='fnname'>loop_while</a>&lt;'queue, R, F&gt;(&amp;'queue self, task: F) -&gt; <a class='struct' href='../taskqueue/struct.FutureGuard.html' title='taskqueue::FutureGuard'>FutureGuard</a>&lt;R&gt; <span class='where'>where F: <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.Fn.html' title='core::ops::Fn'>Fn</a>() -&gt; <a class='enum' href='../taskqueue/enum.LoopResult.html' title='taskqueue::LoopResult'>LoopResult</a>&lt;R&gt; + <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Send.html' title='core::marker::Send'>Send</a> + <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html' title='core::marker::Sync'>Sync</a> + 'queue, R: <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Send.html' title='core::marker::Send'>Send</a> + 'static</span> { ... }
}</pre><div class='docblock'><p>Basic Queue Trait defining all possible operations on Queues</p>

<p>Queues implement this, so you may use a unified Interface for all Queues.</p>
</div>
            <h2 id='required-methods'>Required Methods</h2>
            <div class='methods'>
        <h3 id='tymethod.async' class='method stab '><code>fn <a href='#tymethod.async' class='fnname'>async</a>&lt;R, F&gt;(&amp;self, task: F) -&gt; <a class='struct' href='../taskqueue/struct.Future.html' title='taskqueue::Future'>Future</a>&lt;R&gt; <span class='where'>where R: <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Send.html' title='core::marker::Send'>Send</a> + 'static, F: <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.FnOnce.html' title='core::ops::FnOnce'>FnOnce</a>() -&gt; R + <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Send.html' title='core::marker::Send'>Send</a> + 'static</span></code></h3><div class='docblock'><p>Runs a task asynchrously on this queue</p>

<p><code>async</code> may not capture values on the current stack, as the closure may live longer then
the current stack. For example, if you drop the Future and the Queue directly afterwards.
Your task will still be executed in that case.</p>

<h1 id='arguments' class='section-header'><a href='#arguments'>Arguments</a></h1>
<p><em>task</em> - Task to be run by the queue</p>

<h1 id='example' class='section-header'><a href='#example'>Example</a></h1><pre class='rust rust-example-rendered'>
<span class='ident'>queue</span>.<span class='ident'>async</span>(<span class='op'>||</span> { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello Queue!&quot;</span>) });</pre>

<p>Note that this limitation does not mean you cannot <em>move</em> variables, this is totally fine:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>name</span> <span class='op'>=</span> <span class='string'>&quot;Welt&quot;</span>.<span class='ident'>to_string</span>();
<span class='ident'>queue</span>.<span class='ident'>async</span>(<span class='kw'>move</span> <span class='op'>||</span> { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello {}!&quot;</span>, <span class='ident'>name</span>) });</pre>
</div></div>
            <h2 id='provided-methods'>Provided Methods</h2>
            <div class='methods'>
        <h3 id='method.scoped' class='method stab '><code>fn <a href='#method.scoped' class='fnname'>scoped</a>&lt;'queue, R, F&gt;(&amp;'queue self, task: F) -&gt; <a class='struct' href='../taskqueue/struct.FutureGuard.html' title='taskqueue::FutureGuard'>FutureGuard</a>&lt;R&gt; <span class='where'>where R: <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Send.html' title='core::marker::Send'>Send</a> + 'static, F: <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.FnOnce.html' title='core::ops::FnOnce'>FnOnce</a>() -&gt; R + <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Send.html' title='core::marker::Send'>Send</a> + 'queue</span></code></h3><div class='docblock'><p>Runs a task asynchrously on this queue allowing capture of stack variables</p>

<p><code>scoped</code> may capture stack variables. To ensure the task may not outlive the current
stack scope the returned FutureGuard blocks on drop, waiting for the task to finish
executing. To avoid this behavior use <code>async</code>.</p>

<h1 id='safety' class='section-header'><a href='#safety'>Safety</a></h1>
<p>Note that it is unsafe to leak the returned <code>FutureGuard</code>. Neither mem::forget nor cyclic
RA II structures should be used in combination with FutureGuard as a leak may result
in a dangeling pointer (read crash). This is the same reason thread::scoped was removed
from the standard library. Read more here <a href="https://github.com/rust-lang/rust/issues/24292"><em>24292</em></a>.</p>

<h1 id='arguments-1' class='section-header'><a href='#arguments-1'>Arguments</a></h1>
<p><em>task</em> - Task to be run on this queue</p>

<h1 id='example-1' class='section-header'><a href='#example-1'>Example</a></h1><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>name</span> <span class='op'>=</span> <span class='string'>&quot;Stack&quot;</span>.<span class='ident'>to_string</span>();
<span class='ident'>queue</span>.<span class='ident'>scoped</span>(<span class='op'>||</span> { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello {}!&quot;</span>, <span class='ident'>name</span>) }); <span class='comment'>//note the missing `move`</span>
<span class='comment'>// join to the task occurs here</span></pre>
</div><h3 id='method.sync' class='method stab '><code>fn <a href='#method.sync' class='fnname'>sync</a>&lt;'queue, R, F&gt;(&amp;'queue self, task: F) -&gt; R <span class='where'>where R: <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Send.html' title='core::marker::Send'>Send</a> + 'static, F: <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.FnOnce.html' title='core::ops::FnOnce'>FnOnce</a>() -&gt; R + <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Send.html' title='core::marker::Send'>Send</a> + 'queue</span></code></h3><div class='docblock'><p>Runs a task synchronously on this queue</p>

<p><code>sync</code> returns after the task was executed blocking the current queue.
As a result capturing of stack variables is totally safe with this function
and no Future is required.</p>

<h1 id='arguments-2' class='section-header'><a href='#arguments-2'>Arguments</a></h1>
<p><em>task</em> - Task to be run on this queue</p>

<h1 id='example-2' class='section-header'><a href='#example-2'>Example</a></h1><pre class='rust rust-example-rendered'>
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello {}&quot;</span>, <span class='ident'>queue</span>.<span class='ident'>sync</span>(<span class='op'>||</span> { <span class='string'>&quot;from another queue&quot;</span>.<span class='ident'>to_string</span>() }));</pre>
</div><h3 id='method.foreach' class='method stab '><code>fn <a href='#method.foreach' class='fnname'>foreach</a>&lt;'queue, B, R, I, F&gt;(&amp;'queue self, iter: I, task: F) -&gt; <a class='struct' href='../taskqueue/struct.Group.html' title='taskqueue::Group'>Group</a>&lt;R&gt; <span class='where'>where B: <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Send.html' title='core::marker::Send'>Send</a>, R: <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Send.html' title='core::marker::Send'>Send</a> + 'queue, I: <a class='trait' href='https://doc.rust-lang.org/nightly/core/iter/trait.Iterator.html' title='core::iter::Iterator'>Iterator</a>&lt;Item=B&gt; + <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Send.html' title='core::marker::Send'>Send</a>, F: <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.Fn.html' title='core::ops::Fn'>Fn</a>(B) -&gt; R + <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Send.html' title='core::marker::Send'>Send</a> + <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html' title='core::marker::Sync'>Sync</a> + 'queue</span></code></h3><div class='docblock'><p>Runs a task once for each iterator elem on this queue</p>

<p><code>foreach</code> queues one task multiple times for each iterator element
of the iterator passed consuming it. It returns a Group containing the
FutureGuards of all executions. Note that Group also implements the Itertor trait.</p>

<h1 id='arguments-3' class='section-header'><a href='#arguments-3'>Arguments</a></h1>
<p><em>iter</em> - Iterator to be consumed
<em>task</em> - Task to be run for <code>iter</code> on this queue</p>

<h1 id='example-3' class='section-header'><a href='#example-3'>Example</a></h1><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>squared</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>queue</span>.<span class='ident'>foreach</span>((<span class='number'>0</span>..<span class='number'>20</span>), <span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>x</span><span class='op'>*</span><span class='ident'>x</span>).<span class='ident'>wait</span>().<span class='ident'>collect</span>();</pre>
</div><h3 id='method.loop_while' class='method stab '><code>fn <a href='#method.loop_while' class='fnname'>loop_while</a>&lt;'queue, R, F&gt;(&amp;'queue self, task: F) -&gt; <a class='struct' href='../taskqueue/struct.FutureGuard.html' title='taskqueue::FutureGuard'>FutureGuard</a>&lt;R&gt; <span class='where'>where F: <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.Fn.html' title='core::ops::Fn'>Fn</a>() -&gt; <a class='enum' href='../taskqueue/enum.LoopResult.html' title='taskqueue::LoopResult'>LoopResult</a>&lt;R&gt; + <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Send.html' title='core::marker::Send'>Send</a> + <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html' title='core::marker::Sync'>Sync</a> + 'queue, R: <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Send.html' title='core::marker::Send'>Send</a> + 'static</span></code></h3><div class='docblock'><p>Loops a task on this queue while a condition is hold</p>

<p><code>loop_while</code> queues a task again and again until it returns <code>Done</code>.
Note that this is perferred over:</p>
<pre class='rust rust-example-rendered'>
<span class='ident'>queue</span>.<span class='ident'>async</span>(<span class='op'>||</span> {
    <span class='kw'>loop</span> { <span class='comment'>//this is bad</span>
         <span class='comment'>/* your task */</span>
    }
});</pre>

<p>because <code>loop_while</code> allows other queued tasks to run in the meantime, because the task
is queued again and again, while the code above runs as one long task.</p>

<p>Note that this is especially useful in combination with <code>SerialQueue::init_main</code> to create
a main thread application run loop.</p>

<h1 id='arguments-4' class='section-header'><a href='#arguments-4'>Arguments</a></h1>
<p><em>task</em> - Task to be looped on this queue</p>

<h1 id='example-4' class='section-header'><a href='#example-4'>Example</a></h1><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>program</span> <span class='op'>=</span> <span class='ident'>Program</span>;

<span class='ident'>queue</span>.<span class='ident'>loop_while</span>(<span class='kw'>move</span> <span class='op'>||</span> {
   <span class='kw'>match</span> <span class='ident'>program</span>.<span class='ident'>did_exit</span>() {
       <span class='prelude-val'>Some</span>(<span class='ident'>exit_code</span>) <span class='op'>=&gt;</span> <span class='ident'>LoopResult</span>::<span class='ident'>Done</span>(<span class='ident'>exit_code</span>),
       <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> {
           <span class='ident'>program</span>.<span class='ident'>tick</span>();
           <span class='ident'>LoopResult</span>::<span class='ident'>Continue</span>
      },
   }
}).<span class='ident'>get</span>();</pre>
</div></div>
        <h2 id='implementors'>Implementors</h2>
        <ul class='item-list' id='implementors-list'>
    <li><code>impl <a class='trait' href='../taskqueue/trait.Queue.html' title='taskqueue::Queue'>Queue</a> for <a class='struct' href='../taskqueue/struct.SerialQueue.html' title='taskqueue::SerialQueue'>SerialQueue</a></code></li>
<li><code>impl&lt;'a, T: 'static&gt; <a class='trait' href='../taskqueue/trait.Queue.html' title='taskqueue::Queue'>Queue</a> for <a class='struct' href='../taskqueue/struct.BoundSerialQueue.html' title='taskqueue::BoundSerialQueue'>BoundSerialQueue</a>&lt;'a, T&gt;</code></li>
<li><code>impl <a class='trait' href='../taskqueue/trait.Queue.html' title='taskqueue::Queue'>Queue</a> for <a class='struct' href='../taskqueue/struct.ConcurrentQueue.html' title='taskqueue::ConcurrentQueue'>ConcurrentQueue</a></code></li>
</ul><script type="text/javascript" async
                              src="../implementors/taskqueue/trait.Queue.js">
                      </script></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "taskqueue";
        window.playgroundUrl = "";
    </script>
    <script src="../jquery.js"></script>
    <script src="../main.js"></script>
    
    <script defer src="../search-index.js"></script>
</body>
</html>