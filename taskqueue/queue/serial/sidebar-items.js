initSidebarItems({"fn":[["init_main","Convert the main thread into a SerialQueueThis function warps the current thread into a SerialQueue, that is passed to the executed function, blocking the current thread until the created Queue is done.This function is only intended to be used on the main thread and library creators should never need to use it.If you need a queue based on a newly created OS thread use `SerialQueue::new_native()`.Example"]],"struct":[["BoundSerialQueue","A bound SerialQueue holding a queue-bound variableCreate a BoundSerialQueue using `SerialQueue::with`. BoundSerialQueue's hold variables that may be used through tasks executed on this queue though `scoped_with`, `sync_with` `foreach_with` or `loop_while_with`.`async_with` cannot be provided, as the bound variable is dropped, when the BoundSerialQueue gets dropped.Internally BoundSerialQueue refer to the same queue, they were created from. Multiple BoundSerialQueue's may exist for one queue at once."],["SerialQueue","Queue executing Tasks serially, non-overlapping in queued OrderPropertiesexecutes tasks in serial order no tasks may overlap they never change their native background thread (but may share it) the tasks are executed in order of queuing safety against deadlocks from recursive queueing (see example) Through these guarantees SerialQueues may bound to a type that is **not** Send or Sync and provide easy thread safe access to this critcal resource. Such a SerialQueue is called *BoundSerialQueue*.Example"]]});